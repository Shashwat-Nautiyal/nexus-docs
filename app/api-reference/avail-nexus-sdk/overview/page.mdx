---
title: "Get Started"
---

import { Callout, Steps, Tabs } from 'nextra/components';

# Get Started

<Callout type="info">
    We built a React demo app that uses the Avail Nexus SDK UI components to implement a unified Web3 experience.

    1. You can use the app here: [`nexus-ui-components-demo.vercel.app`](https://nexus-ui-components-demo.vercel.app/)
    2. You can find the code for the app here: [`availproject/nexus-ui-components-demo`](https://github.com/availproject/nexus-ui-components-demo)
</Callout>


The Avail Nexus SDK provides both headless functionality and pre-built React UI components. This guide covers the **React UI components** which offer the fastest way to integrate chain abstraction into your React app.

<Callout type="info">
The SDK provides `BridgeButton`, `TransferButton`, and `BridgeAndExecuteButton` components. Each widget is covered in detail in the following pages.
</Callout>


The Avail Nexus SDK provides some built-in React widgets that make it easier for devs to
integrate the SDK into their existing React app.

### Get `NexusProvider`

Wrap your app with the `NexusProvider`.

Enable the Nexus SDK functionality by adding the `NexusProvider` to your app's root component. (For e.g.,`layout.tsx` in Next.js or `App.tsx` in Remix, etc.):

```tsx showLineNumbers filename="__root.tsx"
import { NexusProvider } from '@avail-project/nexus/ui';

export default function Root() {
  return (
    <NexusProvider
      config={{
        network: 'testnet', // "mainnet" (default) or "testnet"
      }}
    >
      <App />
    </NexusProvider>
  );
}
```

<Callout type="info">
**FOR EXAMPLE:**<br/>

The demo app sets up the `NexusProvider` in the [__root.tsx](https://github.com/availproject/nexus-ui-components-demo/blob/main/src/routes/__root.tsx#L50) file, 
wrapping the entire application with both wallet authentication (Privy) and the Nexus provider.
</Callout>

<Tabs items={['Use UI Components', 'Manual Initialization']}>

<Tabs.Tab>

### Set Wallet Provider

Forward the user's wallet provider.

Connect your wallet library to the Nexus SDK by forwarding the provider:

```tsx showLineNumbers filename="WalletBridge.tsx"
import { useEffect } from 'react';
import { useAccount } from '@wagmi/react'; // any wallet lib works
import { useNexus } from '@avail-project/nexus/ui';

export function WalletBridge() {
  const { connector, isConnected } = useAccount();
  const { setProvider } = useNexus();

  useEffect(() => {
    if (isConnected && connector?.getProvider) {
      connector.getProvider().then(setProvider);
    }
  }, [isConnected, connector, setProvider]);

  return null;
}
```

<Callout>
**Any wallet library works:** The example shows Wagmi, but you can use Privy, RainbowKit, ConnectKit, or any library that provides an EIP-1193 provider.

The demo app uses Privy and forwards the provider in [connect-wallet.tsx](https://github.com/availproject/nexus-ui-components-demo/blob/main/src/components/connect-wallet.tsx#L16).
</Callout>

### Use UI Widget

Drop a widget into your UI.

Use the pre-built UI components for common chain abstraction operations. The following example
shows how you would use the bridge, but other widgets are covered in the following pages:

```tsx showLineNumbers filename="App.tsx"
import {
  BridgeButton,
} from '@avail-project/nexus';

/*  Bridge ----------------------------------------------------------- */
<BridgeButton prefill={{ chainId: 137, token: 'USDC', amount: '100' }}>
  {({ onClick, isLoading }) => (
    <button onClick={onClick} disabled={isLoading}>
      {isLoading ? 'Bridging…' : 'Bridge 100 USDC → Polygon'}
    </button>
  )}
</BridgeButton>
```

</Tabs.Tab>

<Tabs.Tab>

### Manual initialization

You can also manually initialize the SDK instead of leaving it up to the UI components.
The code snippet below shows how:

<Callout>
You still need to wrap your app with the `NexusProvider` before proceeding with the manual initialization.
</Callout>

```tsx showLineNumbers filename="App.tsx"
import { useNexus } from '@avail-project/nexus/ui';

function MyComponent() {
  const { initializeSdk, sdk, isSdkInitialized } = useNexus();

  const handleInitialize = async () => {
    const provider = await window.ethereum; // or get from your wallet library
    await initializeSdk(provider); // Initializes both SDK and UI state

    // Now you can use SDK methods directly
    const balances = await sdk.getUnifiedBalances();
    console.log('Balances:', balances);

    // UI components will already be initialized when used
  };

  return (
    <button onClick={handleInitialize} disabled={isSdkInitialized}>
      {isSdkInitialized ? 'SDK Ready' : 'Initialize SDK'}
    </button>
  );
}
```

<Callout type="info">
**WHAT THIS MEANS?**<br/>

1. The `useNexus` hook now shares the initialized SDK instance with the UI components.
2. Earlier the end user would have needed to sign two signatures, one for the SDK to be able to fetch their unified balance,
and one for the SDK to use the UI components to sign transactions.
3. With the shared state, just one signature is needed to initialize the SDK and use the UI components.
</Callout>

</Tabs.Tab>

</Tabs>

<details className="border p-3 rounded-md bg-[#EFF6FF]">
<summary>What do we mean by "unified balance"?</summary>

Unified balance shows all the liquidity in a user's EOA account across multiple chains in one view. It lets users transact seamlessly on any chain without needing bridges or pre-provisioning gas for token swaps. Chain abstraction handles all the complexity involved in a cross-chain transaction while enabling better UX through a single intent approval.

For instance, let us take the case where a user intends to spend 18 USDC on Scroll and does not have any balance on Scroll.

- Optimism: 0.1 ETH, O USDT, 0 USDC
- Arbitrum: 0 ETH, 12 USDT, 0 USDC
- Base: 0 ETH, 10 USDT, 0 USDC
- Scroll: 0 ETH, 0 USDT, 0 USDC

To spend 18 USDC on Scroll (destination chain) with the given liquidity fragmentation, it would typically require multiple clicks and steps for swapping or bridging different assets available on the source chains, so that user can convert the assets to the desired token balance on Scroll.

Through chain abstraction and ability to swap cross-chain, users have the convenience to view the consolidated token balance across supported tokens and chains. This simplifies the process of sending 18 USDC on Optimism, as users can sign the intent without the need for bridging, swapping, or considering the optimal routes.

The cross-chain swap enables users to:

- Spend assets on any destination chain without prior liquidity.
- Collate payable amount by combining multiple supported assets across source chains to address liquidity fragmentation.
</details>