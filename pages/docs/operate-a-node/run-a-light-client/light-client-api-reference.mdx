---
id: avail-light-client-reference
title: API reference
sidebar_label: Avail Light client API reference
description: Avail Light client API reference
keywords:
  - docs
  - avail
  - data
  - availability
  - how-to
  - light client
  - embedding
  - rust
  - API
  - reference
image: https://docs.availproject.org/img/avail/AvailDocs.png
---
import { Tabs } from 'nextra/components'
import { Callout } from 'nextra/components'

# Avail Light Client reference

<Callout type="info">
BEFORE WE START
1. The indiviual behaviour of some methods may differ depending on which mode the light client is runnning in.
This will be documented in the individual method descriptions.
2. The `API-v2` is an improved version of `API-v1` with a focus on improving devex.
In the near future, another upgrade to the light client API will remove versioning altogether.
Any such changes will be documented here.
3. The methods documented here were tested on a locally running instance of the Avail light client.
They will however work with remotely hosted instances as well.
</Callout>

## API-v1

### v1/latest_block

Allows us to fetch the latest block processed by light client.

*Params*:
- None

*Response*:
- Latest block number

<Tabs items={['CURL', 'Rust']}>

<Tabs.Tab>
```sh
curl "http://localhost:7000/v1/latest_block"
```
</Tabs.Tab>

<Tabs.Tab>

```rust
use reqwest::StatusCode;
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct LatestBlock {
    pub latest_block: u32,
}

const LIGHT_CLIENT_URL: &str = "http://localhost:7000";

let latest_block_url = format!("{LIGHT_CLIENT_URL}/v1/latest_block");
let response = reqwest::get(latest_block_url).await.unwrap();

if response.status() == StatusCode::OK {
    let latest_block: LatestBlock =
        serde_json::from_str(&response.text().await.unwrap()).unwrap();
    println!("{latest_block:?}");
}
// ...error handling...
```
</Tabs.Tab>
</Tabs>

<details className="border p-3 rounded-md bg-[#EFF6FF] border-[#] hover:!bg-[#EFF6FF]">
<summary> Sample Response:</summary>
```json
{
  "latest_block": 10
}
```
</details>

<Callout>
The `localhost` namespace should allow you to access your local port where the Avail LC is running.
If however you get no response, try replacing `localhost` with `127.0.0.1`.
This is a known issue and we are looking into this.
</Callout>

### v1/confidence/&#123;block_number&#125;

Allows us to fetch the confidence in % for a given block number.

*Params*:
- block number

*Response*:
- block number
- confidence in %
- serialised confidence

<Tabs items={['CURL', 'Rust']}>

<Tabs.Tab>
```sh
curl "http://localhost:7000/v1/confidence/1"
```

<details className="border p-3 rounded-md bg-[#EFF6FF] border-[#] hover:!bg-[#EFF6FF]">
<summary>Sample Response:</summary>

```json
{
  "block": 1,
  "confidence": 93.75,
  "serialised_confidence": "5232467296"
}
```
</details>

</Tabs.Tab>

<Tabs.Tab>
```rust
use reqwest::StatusCode;
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Confidence {
    pub block: u32,
    pub confidence: f64,
    pub serialised_confidence: Option<String>,
}

const LIGHT_CLIENT_URL: &str = "http://localhost:7000";

let block_number = 1;
let confidence_url = format!("{LIGHT_CLIENT_URL}/v1/confidence/{block_number}");
let response = reqwest::get(confidence_url).await.unwrap();

if response.status() == StatusCode::OK {
    let confidence: Confidence =
        serde_json::from_str(&response.text().await.unwrap()).unwrap();
    println!("{confidence:?}");
}
// ...error handling...
```

</Tabs.Tab>
</Tabs>

If confidence is not computed, and specified block is before the latest processed block:

```json
"Not synced"
```

If confidence is not computed, and specified block is after the latest processed block:

```json
"Not found"
```

### v1/appdata/&#123;block_number&#125;

Given a block number, it retrieves the hex-encoded extrinsics for the specified block, if available. 
Alternatively, if specified by a query parameter, the retrieved extrinsic is decoded and returned as 
a base64-encoded string.

*Params*:
- `block_number` - block number (required)
- `decode` - `true` if decoded extrinsics are requested (boolean, optional, default is `false`)

*Response*:
- If application data is available, and decode is `false` or unspecified:

```json
{
  "block": 1,
  "extrinsics": [
    "0xc5018400d43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d01308e88ca257b65514b7b44fc1913a6a9af6abc34c3d22761b0e425674d68df7de26be1c8533a7bbd01fdb3a8daa5af77df6d3fb0a67cde8241f461f4fe16f188000000041d011c6578616d706c65"
  ]
}
```

If application data is available, and decode is `true`:

```json
{ "block": 1, "extrinsics": ["ZXhhbXBsZQ=="] }
```

<Tabs items={['CURL', 'Rust']}>

<Tabs.Tab>
#### JSON response

```sh
curl "http://localhost:7000/v1/appdata/1?decode=true"
```
</Tabs.Tab>

<Tabs.Tab>

```rust

use base64::Engine as _;
use reqwest::StatusCode;
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct ExtrinsicsData {
    pub block: u32,
    pub extrinsics: Vec<String>,
}

const LIGHT_CLIENT_URL: &str = "http://localhost:7000";

let block_number = 2;
let confidence_url = format!("{LIGHT_CLIENT_URL}/v1/appdata/{block_number}?decode=true");
let response = reqwest::get(confidence_url).await.unwrap();

if response.status() == StatusCode::OK {
    let data: ExtrinsicsData =
        serde_json::from_str(&response.text().await.unwrap()).unwrap();

    let decoded_bytes = engine::general_purpose::STANDARD
        .decode(&data.extrinsics[0])
        .unwrap();
    let decoded_string = String::from_utf8(decoded_bytes).unwrap();
    println!("{decoded_string:?}");
}

// ...error handling...
```
</Tabs.Tab>
</Tabs>

<details className="border p-3 rounded-md bg-[#EFF6FF] border-[#] hover:!bg-[#EFF6FF]">
<summary>Sample Response:</summary>

```json
{
  "block": 46,
  "extrinsics": ["ZXhhbXBsZQ=="]
}
```
</details>

If application data is not available, and specified block is the latest block:

```json
"Processing block"
```

If application data is not available, and specified block is not the latest block:

```json
"Not found"
```

### v1/mode

Retrieves the operating mode of the Avail light client. The Light client can operate in two different modes,
`LightClient` or `AppClient`, depending on configuration of application ID(`app-id`) flag.

*Params*:
- None

*Response*:
- Operating mode


If operating mode is `LightClient` response is:

```json
"LightClient"
```

In case of `AppClient` mode, response is:

```json
{"AppClient": {app_id}}
```

### v1/status

Retrieves the status of the latest block processed by the light client.

*Params*:
- None

*Response*:
- Latest block number
- Confidence in %
- App ID



<details className="border p-3 rounded-md bg-[#EFF6FF] border-[#] hover:!bg-[#EFF6FF]">
<summary>Sample Response:</summary>

```json
{ 
  "block_num": 89,
  "confidence": 93.75,
  "app_id": 1 
}
```
</details>



If there are no processed blocks:

```json
"Not found"
```

## API-v2

### v2/version

Gets the version of the light client binary, and the version of the compatible network.

*Params*:
- None

*Response*:
- Light Client version
- Network version

<Tabs items={['CURL']}>

<Tabs.Tab>
```sh
curl "http://127.0.0.1:7000/v2/version"
```
</Tabs.Tab>
</Tabs>


<details className="border p-3 rounded-md bg-[#EFF6FF] border-[#] hover:!bg-[#EFF6FF]">
<summary> Sample Response:</summary>
```json
{
  "version":"v1.7.8",
  "network_version":"1.10"
}  
```
</details>


### v2/status

Gets current status and active modes of the light client.

*Params*:
- None

*Response*:
- **modes** - active modes
- **app_id** - if **app** mode is active, this field contains configured application ID
- **genesis_hash** - genesis hash of the network to which the light client is connected
- **network** - network host, version and spec version light client is currently con
- **blocks** - state of processed blocks
- **partition** - if configured, displays partition which light client distributes to the peer to peer network

#### Modes

- **light** - data availability sampling mode, the light client performs random sampling and calculates confidence
- **app** - light client fetches, verifies, and stores application-related data
- **partition** - light client fetches configured block partition and publishes it to the DHT

#### Blocks

- **latest** - block number of the latest [finalized](https://docs.substrate.io/learn/consensus/) block received from the node
- **available** - range of blocks with verified data availability (configured confidence has been achieved)
- **app_data** - range of blocks with app data retrieved and verified
- **historical_sync** - state for historical blocks syncing up to configured block (ommited if historical sync is not configured)

#### Historical sync

- **synced** - `true` if there are no historical blocks left to sync
- **available** - range of historical blocks with verified data availability (configured confidence has been achieved)
- **app_data** - range of historical blocks with app data retrieved and verified

<Tabs items={['CURL']}>

<Tabs.Tab>
```sh
curl "http://127.0.0.1:7000/v2/status"
```

</Tabs.Tab>
</Tabs>


<details className="border p-3 rounded-md bg-[#EFF6FF] border-[#] hover:!bg-[#EFF6FF]">
<summary> Sample Response:</summary>
```json
{
  "modes":["light"],
  "genesis_hash":"0x6f09966420b2608d1947ccfb0f2a362450d1fc7fd902c29b67c906eaa965a7ae",
  "network":"wss://goldberg.avail.tools:443/ws/1.11.0-38304bb5126/data-avail/22",
  "blocks":{
    "latest":572269,
    "available":{
      "first":572068,
      "last":572268
    }
  }
}
```
</details>

### v2/blocks/&#123;block_number&#125;

Gets specified block status and confidence if applicable.

**Use cases:**
  - Polling the status of the block
  - Querying historical block statuses

*Params*:
- `block_number` - block number (required)

*Response*:
- **status** - block status
- **confidence** - data availability confidence, available if block processing is finished.


<Tabs items={['CURL']}>
<Tabs.Tab>
```sh
curl "http://127.0.0.1:7000/v2/blocks/672481"
```
</Tabs.Tab>
</Tabs>

<details className="border p-3 rounded-md bg-[#EFF6FF] border-[#] hover:!bg-[#EFF6FF]">
<summary> Sample Response:</summary>
```json
{
  "status":"verifying-data",
  "confidence":99.90234375
}
```
</details>

#### Status

- **unavailable** - block will not be processed if
  \
  **latest_block - sync_depth > block_number**
- **pending** - block will be processed at some point in the future if
  \
  **latest_block - sync_depth ≤ block_number ≤ latest_block**
- **verifying-header** - block processing is started, and the header finality is being checked
- **verifying-confidence** - block header is verified and available, confidence is being checked
- **verifying-data** - confidence is achieved, and data is being fetched and verified (if configured)
- **finished** - block header is available, confidence is achieved, and data is available (if configured)

This status does not give information on what is available. In the case of web sockets messages are already pushed, similar to case of the frequent polling, so header and confidence will be available if **verifying-header** and **verifying-confidence** has been successful.

> If **block_number > latest_block,** block status cannot yet be derived and the response on this and other endpoints with `/v2/blocks/{block_number}` prefix is:

```yaml
Not Found
```

### /v2/blocks/&#123;block_number&#125;/header

Gets the header for a specifc block if available.

*Params*:
- `block_number` - block number (required)

*Response*:

dsdsd

<Tabs items={['CURL']}>
<Tabs.Tab>
```sh
curl "http://127.0.0.1:7000/v2/blocks/572481/header"
```
</Tabs.Tab>
</Tabs>


If **block_status = "verifying-confidence|verifying-data|finished"**, the header is available, and the response is:
```yaml
HTTP/1.1 200 OK
Content-Type: application/json

{
  "hash": "{hash}",
  "parent_hash": "{parent-hash}",
  "number": {number},
  "state_root": "{state-root}",
  "extrinsics_root": "{extrinsics-root}",
  "extension": {
    "rows": {rows},
    "cols": {cols},
    "data_root": "{data-root}", // Optional
    "commitments": [
      "{commitment}", ...
    ],
    "app_lookup": {
      "size": {size},
      "index": [
        {
          "app_id": {app-id},
          "start": {start}
        }
      ]
    }
  }
}
```

If **block_status = "unavailable|pending|verifying-header"**, header is not available and response is:

```yaml
HTTP/1.1 400 Bad Request
```

### **GET** `/v2/blocks/{block_number}/data?fields=data,extrinsic`

Gets the block data if available. Query parameter `fields` specifies whether to return decoded data and encoded extrinsic (with signature). If `fields` parameter is omitted, response contains **hash** and **data**, while **extrinsic** is omitted.

If **block_status = "finished"**, data is available and the response is:

```yaml
HTTP/1.1 200 OK
Content-Type: application/json

{
  "data_transactions": [
    {
      "data": "{base-64-encoded-data}" // Optional
      "extrinsic": "{base-64-encoded-extrinsic}", // Optional
    }
  ]
}
```

If **block_status** is not **“finished”**, or **app** mode is not enabled, data is not available and the response is:

```yaml
HTTP/1.1 400 Bad Request
```

### POST `/v2/submit`

Submits application data to the avail network.\
In case of `data` transaction, data transaction is created, signed and submitted.\
In case of `extrinsic`, externaly created and signed transaction is submitted. Only one field is allowed per request.\
Both `data` and `extrinsic` has to be encoded using base64 encoding.

Request:

```yaml
POST /v2/submit HTTP/1.1
Host: {light-client-url}
Content-Type: application/json
Content-Length: {content-length}

{
  "data": "{base-64-encoded-data}" // Optional
  "extrinsic": "{base-64-encoded-data}" // Optional
}
```

Response:

```yaml
HTTP/1.1 200 OK
Content-Type: application/json

{
  "block_number": {block-number},
  "block_hash": "{block-hash}",
  "hash": "{transaction-hash}",
  "index": {transaction-index}
}
```

If **app** mode is not active (or signing key is not configured and `data` is submitted) response is:

```yaml
HTTP/1.1 404 Not found
```

### Errors

In case of an error, endpoints will return a response with `500 Internal Server Error` status code, and descriptive error message:

```yaml
HTTP/1.1 500 Internal Server Error
Content-Type: text/plain

Internal Server Error
```

## WebSocket API

The Avail Light Client WebSocket API allows real-time communication between a client and a server over a persistent connection, enabling push notifications as an alternative to polling. Web socket API can be used on its own or in combination with HTTP API to enable different pull/push use cases.

### POST `/v2/subscriptions`

Creates subscriptions for given topics. In case of reconnects, the user needs to subscribe again.

Request:

```yaml
POST /v2/subscriptions HTTP/1.1
Host: {light-client-url}
Content-Type: application/json
Content-Length: {content-length}

{
  "topics": ["header-verified", "confidence-achieved", "data-verified"],
  "data_fields": ["data", "extrinsic"]
}
```

Response:

```yaml
HTTP/1.1 200 OK
Content-Type: application/json

{
  "subscription_id": "{subscription-id}"
}
```

#### Topics

- **header-verified** - header finality is verified and header is available
- **confidence-achieved** - confidence is achieved
- **data-verified** - block data is verified and available

#### Data fields

Filters **data-verified** message. Optional parameter used when encoded **extrinsic** is needed. If omitted, only decoded **data** is present in the message.

### GET `/v2/ws/{subscription-id}`

Connects to Avail Light Client web socket. Multiple connections are currently allowed.

### Client-to-server messages

Every request should contain unique **request_id** field, used to correlate request with response.

#### Request version

Request Avail Light Client version data.

```json
{
  "type": "version",
  "request_id": "{uuid}"
}
```

### Request status

Request current Avail Light Client status data.

```json
{
  "type": "status",
  "request_id": "{uuid}"
}
```

### Submit data transaction

Submits data transaction to the Avail.

```json
{
	"type": "submit",
	"request_id": "{uuid}",
	"message": {
		"data": "{base-64-encoded-data}", // Optional
		"extrinsic": "{base-64-encoded-data}" // Optional
	}
}
```

### Server-to-client messages

If response contains ******request_id****** field, it will be pushed to the client which initiated request. Those messages are not subject to a topic filtering at the moment.

#### Version

Version response.

```json
{
  "topic": "version",
  "request_id": "{uuid}",
  "message": {
    "version": "{version-string}",
    "network_version": "{version-string}"
  }
}
```

### Status

Status response.

```json
{
  "topic": "status",
  "request_id": "{uuid}",
  "message": {
    "modes": [
      "light",
      "app",
      "partition"
    ],
    "app_id": {app-id}, // Optional
    "genesis_hash": "{genesis-hash}",
    "network": "{network}",
    "blocks": {
      "latest": {latest},
      "available": {  // Optional
        "first": {first},
        "last": {last}
      },
      "app_data": {  // Optional
        "first": {first},
        "last": {last}
      },
      "historical_sync": {  // Optional
        "synced": false,
        "available": {  // Optional
          "first": {first},
          "last": {last}
        },
        "app_data": {  // Optional
          "first": {first},
          "last": {last}
        }
      }
    },
    "partition": "{partition}"
  }
}
```

#### Data transaction submitted

Data transaction submitted response. It contains transaction **hash** used to correlate transaction with verified data once transaction is included in the block and verified by the light client.

```json
{
  "topic": "data-transaction-submitted",
  "request_id": "{uuid}",
  "message": {
    "block_number": {block-number},
    "block_hash": "{block-hash}",
    "hash": "{transaction-hash}",
    "index": {transaction-index}
  }
}
```

If **app** mode is not active or signing key is not configured error response is sent with descriptive error message.

#### Errors

In case of errors, descriptive error message is sent:

```json
{
  "topic": "error",
  "request_id": "{uuid}", // Optional
  "code": "{error-code}",
  "message": "{descriptive-error-message}"
}
```

Error codes:

- **bad-request** - request sent via web socket message is not valid

#### Header verified

When header verification is finished, the message is pushed to the light client on a **header-verified** topic:

```json
{
  "topic": "header-verified",
  "message": {
    "block_number": {block-number},
    "header": {
      "hash": "{hash}",
      "parent_hash": "{parent-hash}",
      "number": {number},
      "state_root": "{state-root}",
      "extrinsics_root": "{extrinsics-root}",
      "extension": {
        "rows": {rows},
        "cols": {cols},
        "data_root": "{data-root}", // Optional
        "commitments": [
          "{commitment}", ...
        ],
        "app_lookup": {
          "size": {size},
          "index": [
            {
              "app_id": {app-id},
              "start": {start}
            }
          ]
        }
      }
    }
  }
}
```

#### Confidence achieved

When high confidence in data availability is achieved, the message is pushed to the light client on the **confidence-achieved** topic:

```json
{
  "topic": "confidence-achieved",
  "message": {
    "block_number": {block-number},
    "confidence": {confidence} // Optional
  }
}
```

#### Data verified

When high confidence in data availability is achieved, the message is pushed to the light client on the **data-verified** topic:

```json
{
  "topic": "data-verified",
  "message": {
    "block_number": "{block-number}",
    "data_transactions": [{
      "data": "{base-64-encoded-data}", // Optional
      "extrinsic": "{base-64-encoded-extrinsic}" // Optional
    }]
  }
}
```